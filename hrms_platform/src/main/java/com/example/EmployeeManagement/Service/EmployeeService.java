package com.example.EmployeeManagement.Service;

<<<<<<< HEAD
import com.example.EmployeeManagement.DTO.EmployeeCreateRequestDTO;
import com.example.EmployeeManagement.DTO.EmployeeDTO;
import com.example.EmployeeManagement.Exception.EmployeeNotFoundException;
import com.example.EmployeeManagement.Model.Employee;
import com.example.EmployeeManagement.Repository.EmployeeRepository;
import com.example.security.model.User;
import com.example.security.repository.UserRepository;
import com.example.security.util.SecurityUtil;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
=======
import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Service;

import com.example.EmployeeManagement.DTO.EmployeeDTO;
import com.example.EmployeeManagement.Exception.EmployeeNotFoundException;
import com.example.EmployeeManagement.Model.Employee;
import com.example.EmployeeManagement.Model.EmployeePersonal;
import com.example.EmployeeManagement.Repository.EmployeeRepository;
import com.example.hrms_platform_document.entity.Document;
import com.example.hrms_platform_document.repository.DocumentAccessLogRepository;
import com.example.hrms_platform_document.repository.DocumentAuditRepository;
import com.example.hrms_platform_document.repository.DocumentRepository;
import com.example.hrms_platform_document.repository.DocumentVersionRepository;
import com.example.notifications.service.NotificationService;
import com.example.security.util.SecurityUtil;
import com.example.security.service.UserService;
import com.example.time.repository.AttendanceRepository;
import com.example.time.repository.LeaveBalanceRepository;
import com.example.time.repository.LeaveRequestRepository;
import com.example.time.repository.LeaveTypeRepository;
import com.example.time.entity.LeaveBalance;
import com.example.time.entity.LeaveType;

import lombok.AllArgsConstructor;
import org.springframework.transaction.annotation.Transactional;

import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b

@Service
@AllArgsConstructor
public class EmployeeService {

    private EmployeeRepository employeeRepository;
<<<<<<< HEAD
    private EmployeeAccessService employeeAccessService;
    private UserRepository userRepository;
    private SecurityUtil securityUtil;

=======

    private EmployeeAccessService employeeAccessService;

    private UserService userService;

    private SecurityUtil securityUtil;

    private AttendanceRepository attendanceRepository;

    private LeaveRequestRepository leaveRequestRepository;

    private LeaveBalanceRepository leaveBalanceRepository;

    private LeaveTypeRepository leaveTypeRepository;

    private DocumentRepository documentRepository;

    private DocumentVersionRepository documentVersionRepository;

    private DocumentAuditRepository documentAuditRepository;

    private DocumentAccessLogRepository documentAccessLogRepository;

    private NotificationService notificationService;

    private static final List<DefaultLeaveType> DEFAULT_LEAVE_TYPES = List.of(
            new DefaultLeaveType("Bereavement Leave", 3, false),
            new DefaultLeaveType("Casual Leave", 12, false),
            new DefaultLeaveType("Earned Leave", 12, true),
            new DefaultLeaveType("Election Leave", 1, false),
            new DefaultLeaveType("Maternity Leave", 182, false),
            new DefaultLeaveType("Paternity Leave", 8, false)
    );

>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b
    public List<EmployeeDTO> getAllEmployee(){
        employeeAccessService.checkHrOrAdmin();
        return employeeRepository.findAll()
                .stream()
                .map(this::mapToDto)
                .toList();
    }

<<<<<<< HEAD
    public EmployeeDTO getEmployeeById(Long employeeId) {

        employeeAccessService.checkOwnerOrHr(employeeId);

        Employee employee = employeeRepository
                .findByEmployeeId(employeeId)
                .orElseThrow(() -> new EmployeeNotFoundException(employeeId));

        return mapToDto(employee);
    }


=======
    public EmployeeDTO getEmployeeById(Long id){

        employeeAccessService.checkOwnerOrHr(id);
        Employee employee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException(id));
        return mapToDto(employee);
    }

>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b
    public List<EmployeeDTO> getEmployeeByName(String name){
        return employeeRepository.searchByFullName(name)
                .stream()
                .map(this::mapToDto)
                .toList();
    }

<<<<<<< HEAD
    public EmployeeDTO addEmployee(EmployeeCreateRequestDTO request) {

        // ðŸ” get logged-in HR/Admin
        String username = securityUtil.getCurrentUsername();

        User hrUser = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("Logged-in user not found"));

        Employee employee = new Employee();

        // Identity
        employee.setFirstName(request.getFirstName());
        employee.setLastName(request.getLastName());

        // Organization
        employee.setDepartment(request.getDepartment());
        employee.setDesignation(request.getDesignation());
        employee.setEmployeeType(request.getEmployeeType());

        // HR details
        employee.setDateOfJoining(request.getDateOfJoining());
        employee.setCurrentBand(request.getCurrentBand());
        employee.setCurrentExperience(
                request.getCurrentExperience() != null ? request.getCurrentExperience() : 0.0
        );
        employee.setCtc(
                request.getCtc() != null ? request.getCtc() : 0
        );

        // Contact
        employee.setPhoneNumber(request.getPhoneNumber());

        // CREATED BY HR
        employee.setCreatedByHrUserId(hrUser.getEmployeeId());

        // System fields
        employee.setStatus("ACTIVE");
        employee.setCreatedAt(LocalDateTime.now());
        employee.setUpdatedAt(LocalDateTime.now());

        Employee saved = employeeRepository.save(employee);

        return mapToDto(saved);
    }


    public EmployeeDTO updateEmployee(Long id, EmployeeCreateRequestDTO request) {

        Employee existing = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException(id));

        // Update only allowed fields
        existing.setFirstName(request.getFirstName());
        existing.setLastName(request.getLastName());
        existing.setDepartment(request.getDepartment());
        existing.setDesignation(request.getDesignation());
        existing.setEmployeeType(request.getEmployeeType());
        existing.setDateOfJoining(request.getDateOfJoining());
        existing.setCurrentBand(request.getCurrentBand());
        existing.setCurrentExperience(
                request.getCurrentExperience() != null ? request.getCurrentExperience() : existing.getCurrentExperience()
        );
        existing.setCtc(
                request.getCtc() != null ? request.getCtc() : existing.getCtc()
        );
        existing.setPhoneNumber(request.getPhoneNumber());



        // System-managed field
        existing.setUpdatedAt(LocalDateTime.now());
=======
    public EmployeeDTO addEmployee(Employee employee){
        ensureHrManagerAssignment(employee);
        Employee employeeSaved =  employeeRepository.save(employee);
        initializeLeaveBalances(employeeSaved);
        return mapToDto(employeeSaved);
    }

    public EmployeeDTO updateEmployee(Long id, Employee updated){
        Employee existing = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException(id));

        existing.setFirstName(updated.getFirstName());
        existing.setLastName(updated.getLastName());
        existing.setCompanyEmail(updated.getCompanyEmail());
        existing.setDateOfJoining(updated.getDateOfJoining());
        existing.setStatus(updated.getStatus());
        existing.setEmployeeType(updated.getEmployeeType());
        existing.setPhoneNumber(updated.getPhoneNumber());
        existing.setCurrentBand(updated.getCurrentBand());
        existing.setCurrentExperience(updated.getCurrentExperience());
        existing.setDesignation(updated.getDesignation());
        existing.setCtc(updated.getCtc());
        existing.setDepartment(updated.getDepartment());
        if (updated.getManager() != null) {
            existing.setManager(updated.getManager());
        }

        ensureHrManagerAssignment(existing);
>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b

        Employee saved = employeeRepository.save(existing);
        return mapToDto(saved);
    }

<<<<<<< HEAD

    public void deleteEmployeeById(Long employeeId){
        employeeRepository.deleteById(employeeId);
=======
    @Transactional
    public void deleteEmployeeById(Long id) {
        employeeAccessService.checkHrOrAdmin();

        Employee employee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException(id));

        String fullName = (employee.getFirstName() + " " + employee.getLastName()).trim();
        String displayName = !fullName.isBlank() ? fullName : employee.getCompanyEmail();
        String message = "Employee " + displayName + " (ID: " + employee.getEmployeeId() + ") was deleted.";
        notificationService.create("Employee deleted", message, "EMPLOYEE_DELETED", "HR");
        notificationService.create("Employee deleted", message, "EMPLOYEE_DELETED", "ADMIN");

        // Remove manager references for subordinates
        employeeRepository.clearManagerForSubordinates(id);

        // Clear employee's user link to avoid FK issues, then delete user
        if (employee.getUser() != null) {
            employee.setUser(null);
            employeeRepository.save(employee);
        }

        // Delete time records
        attendanceRepository.deleteByEmployeeEmployeeId(id);
        leaveRequestRepository.deleteByEmployeeEmployeeId(id);
        leaveBalanceRepository.deleteByEmployeeEmployeeId(id);

        // Clean document-related references
        documentAccessLogRepository.deleteByEmployeeEmployeeId(id);
        documentAuditRepository.deleteByPerformedByEmployeeId(id);
        documentVersionRepository.deleteByUploadedByEmployeeId(id);

        // For docs approved by this employee, keep docs and clear approver
        documentRepository.clearApprovedByEmployeeId(id);

        // Delete docs owned/uploaded by this employee (and their related records)
        List<Document> docsToDelete = new ArrayList<>(documentRepository.findByEmployeeEmployeeId(id));
        docsToDelete.addAll(documentRepository.findByUploadedByEmployeeId(id));
        if (!docsToDelete.isEmpty()) {
            List<Long> docIds = docsToDelete.stream()
                    .map(Document::getDocumentId)
                    .distinct()
                    .toList();
            for (Long docId : docIds) {
                documentAccessLogRepository.deleteByDocumentDocumentId(docId);
                documentAuditRepository.deleteByDocumentDocumentId(docId);
                documentVersionRepository.deleteByDocumentDocumentId(docId);
            }
            documentRepository.deleteAllById(docIds);
        }

        // Delete the login user so the email (username) is freed for reuse
        userService.deleteByEmployeeId(id);

        employeeRepository.deleteById(id);
>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b
    }


    public EmployeeDTO mapToDto(Employee employee){
        EmployeeDTO dto = new EmployeeDTO();
        dto.setEmployeeId(employee.getEmployeeId());
        dto.setFirstName(employee.getFirstName());
        dto.setLastName(employee.getLastName());
        dto.setCompanyEmail(employee.getCompanyEmail());
        dto.setDesignation(employee.getDesignation());
        dto.setStatus(employee.getStatus());
        dto.setCurrentBand(employee.getCurrentBand());
<<<<<<< HEAD

        if(employee.getJobDetails() != null)
            dto.setDepartment(employee.getJobDetails().getDepartmentName());
        if(employee.getManager()!=null)
            dto.setManagerName(employee.getManager().getFirstName()+" "+employee.getManager().getLastName());
=======
        dto.setDateOfJoining(employee.getDateOfJoining());
        dto.setEmployeeType(employee.getEmployeeType());
        dto.setPhoneNumber(employee.getPhoneNumber());
        dto.setCurrentExperience(employee.getCurrentExperience());
        dto.setCtc(employee.getCtc());
        if (employee.getEmployeePersonal() != null) {
            dto.setPersonalEmail(employee.getEmployeePersonal().getPersonalMail());
        }

        if (employee.getJobDetails() != null)
            dto.setDepartment(employee.getJobDetails().getDepartmentName());
        else if (employee.getDepartment() != null)
            dto.setDepartment(employee.getDepartment());
        if(employee.getManager()!=null)
            dto.setManagerName(employee.getManager().getFirstName()+" "+employee.getManager().getLastName());
        if (employee.getManager() != null)
            dto.setManagerId(employee.getManager().getEmployeeId());
>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b

        return dto;
    }

<<<<<<< HEAD
=======
    private void initializeLeaveBalances(Employee employee) {
        if (employee == null) {
            return;
        }
        ensureDefaultLeaveTypes();
        List<LeaveType> leaveTypes = leaveTypeRepository.findAll();
        Set<Long> existingTypeIds = leaveBalanceRepository.findByEmployee(employee)
                .stream()
                .map(LeaveBalance::getLeaveTypeId)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        for (LeaveType type : leaveTypes) {
            if (type.getLeaveTypeId() == null || existingTypeIds.contains(type.getLeaveTypeId())) {
                continue;
            }
            LeaveBalance balance = new LeaveBalance();
            balance.setEmployee(employee);
            balance.setLeaveTypeId(type.getLeaveTypeId());
            Integer total = type.getMaxPerYear();
            balance.setTotalLeaves(total);
            balance.setUsedLeaves(0);
            balance.setRemainingLeaves(total);
            leaveBalanceRepository.save(balance);
        }
    }

    private void ensureDefaultLeaveTypes() {
        for (DefaultLeaveType def : DEFAULT_LEAVE_TYPES) {
            LeaveType existing = leaveTypeRepository.findByLeaveNameIgnoreCase(def.name).orElse(null);
            if (existing == null) {
                LeaveType created = new LeaveType();
                created.setLeaveName(def.name);
                created.setMaxPerYear(def.maxPerYear);
                created.setCarryForwardAllowed(def.carryForwardAllowed);
                leaveTypeRepository.save(created);
                continue;
            }

            boolean updated = false;
            if (!Objects.equals(existing.getMaxPerYear(), def.maxPerYear)) {
                existing.setMaxPerYear(def.maxPerYear);
                updated = true;
            }
            if (!Objects.equals(existing.getCarryForwardAllowed(), def.carryForwardAllowed)) {
                existing.setCarryForwardAllowed(def.carryForwardAllowed);
                updated = true;
            }
            if (updated) {
                leaveTypeRepository.save(existing);
            }
        }
    }

    private static class DefaultLeaveType {
        private final String name;
        private final Integer maxPerYear;
        private final Boolean carryForwardAllowed;

        private DefaultLeaveType(String name, Integer maxPerYear, Boolean carryForwardAllowed) {
            this.name = name;
            this.maxPerYear = maxPerYear;
            this.carryForwardAllowed = carryForwardAllowed;
        }
    }

>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b
    public List<EmployeeDTO> getEmployeesUnderManager(Long managerId) {

        // HR can view anyone, EMPLOYEE only their own subordinates
        employeeAccessService.checkManagerAccess(managerId);

        return employeeRepository.findByManager_EmployeeId(managerId)
                .stream()
                .map(this::mapToDto)
                .toList();
    }
<<<<<<< HEAD
    public Employee toEntity(EmployeeCreateRequestDTO dto, Long hrUserId) {

        Employee e = new Employee();

        e.setFirstName(dto.getFirstName());
        e.setLastName(dto.getLastName());
        e.setDepartment(dto.getDepartment());
        e.setDesignation(dto.getDesignation());
        e.setEmployeeType(dto.getEmployeeType());
        e.setDateOfJoining(dto.getDateOfJoining());
        e.setPhoneNumber(dto.getPhoneNumber());

        // NULL-SAFE DEFAULTS
        e.setCurrentExperience(
                dto.getCurrentExperience() != null ? dto.getCurrentExperience() : 0.0
        );

        e.setCtc(
                dto.getCtc() != null ? dto.getCtc() : 0
        );

        e.setCurrentBand(dto.getCurrentBand());
        e.setStatus("ACTIVE");

        // Audit
        e.setCreatedByHrUserId(hrUserId);

        return e;
    }



    public Employee addEmployeeInternal(Employee employee) {
//        employee.setEmployeeId(null);
        return employeeRepository.save(employee);
    }


=======

    public Employee toEntity(EmployeeDTO dto, Long hrUserId) {
        Employee e = new Employee();
        e.setFirstName(dto.getFirstName());
        e.setLastName(dto.getLastName());
        e.setCompanyEmail(dto.getCompanyEmail());
        e.setDateOfJoining(dto.getDateOfJoining());
        e.setStatus(dto.getStatus());
        e.setEmployeeType(dto.getEmployeeType());
        e.setPhoneNumber(dto.getPhoneNumber());
        e.setCurrentBand(dto.getCurrentBand());
        e.setCurrentExperience(dto.getCurrentExperience());
        e.setDesignation(dto.getDesignation());
        e.setCtc(dto.getCtc());
        e.setDepartment(dto.getDepartment());
        e.setCreatedByHrUserId(hrUserId);
        if (dto.getPersonalEmail() != null && !dto.getPersonalEmail().isBlank()) {
            EmployeePersonal personal = new EmployeePersonal();
            personal.setPersonalMail(dto.getPersonalEmail().trim());
            personal.setEmployee(e);
            e.setEmployeePersonal(personal);
        }
        if (dto.getManagerId() != null) {
            Employee manager = employeeRepository.findById(dto.getManagerId())
                    .orElseThrow(() -> new EmployeeNotFoundException(dto.getManagerId()));
            e.setManager(manager);
        }
        ensureHrManagerAssignment(e);
        return e;
    }

    private void ensureHrManagerAssignment(Employee employee) {
        if (!securityUtil.isHrEmployee(employee)) {
            return;
        }
        if (securityUtil.isHrManager(employee)) {
            return;
        }
        if (employee.getManager() == null) {
            Employee autoManager = securityUtil.findHrManagerForDepartment(employee.getDepartment())
                    .orElseThrow(() -> new RuntimeException("HR Manager not found for department"));
            employee.setManager(autoManager);
        }
        Employee manager = employee.getManager();
        if (!securityUtil.isHrManager(manager)) {
            throw new RuntimeException("HR employee must have an HR Manager");
        }
        if (!sameDepartment(employee.getDepartment(), manager.getDepartment())) {
            throw new RuntimeException("HR Manager must be in same department");
        }
    }

    private boolean sameDepartment(String deptA, String deptB) {
        if (deptA == null || deptB == null) {
            return false;
        }
        return deptA.trim().equalsIgnoreCase(deptB.trim());
    }



>>>>>>> 985c4a38cd5976c42713aa6a5f975a1278287d1b
}
